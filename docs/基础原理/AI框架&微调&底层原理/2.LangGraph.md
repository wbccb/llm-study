# LangGraph

LangGraph是一个用于构建大模型语言模型Agent的编排框架，它是LangChain的一个扩展，旨在通过将步骤建模为图中的边和节点，构建强大并且有状态的多参与者应用程序

> `LangGraph`=`LangChain` +  图状态机 + 循环控制 + 多代理调度

> 使用`有向图`建模复杂的代理工作流，支持循环、条件分支、状态管理，是构建复杂、有状态、多步骤代理工作流的扩展工具，适用于`步步推理、需要循环或者反馈的流程`


比如下面的示例就展现出`LangGraph`基于图的声明式编程，每一个节点都是一个动作（比如调用LLM、执行tool工具），边表示状态转移
```python
from langgraph.graph import StateGraph, END

class AgentState(TypedDict):
    messages: Annotated[Sequence[BaseMessage], add_messages]
    next: str

graph = StateGraph(AgentState)
graph.add_node("planner", planner_node)
graph.add_node("executor", executor_node)
graph.add_conditional_edges("planner", router_func, {"continue": "executor", "end": END})
graph.add_edge("executor", "planner")  # 可以形成循环
app = graph.compile()
```

## 核心概念

图构建StateGraph，用于构建有向图

- `add_node()`：添加节点
- `add_adge()`：添加普通边
- `add_conditional_edges()`：添加条件边
- `set_entry_point()`：设置入口点
- `set_finish_point()`：设置结束点

### 状态
整个工作流中的共享的数据结构，通常使用`TypedDict`定义

### 节点
图中的执行单位，代表一个具体的操作，比如调用LLM、执行工具等

### 边

连接节点的路径，定义执行流程，主要有两种类型
- 普通边：固定从给一个节点到另一个节点
- 条件边：根据状态决定下一步走向


## 最小化demo

定义状态
```python
from typing import TypedDict, Annotated
from langgraph.graph.message import add_messages

class AgentState(TypedDict):
    messages: Annotated[list, add_messages] #自动合并消息
    next: str # 下一步执行的节点
```

创建基础的函数
```python
# 创建节点函数
def planner_node(state):
    # 处理规划逻辑
    return {"messages": [response], "next": "executor"}

def executor_node(state):
    # 执行具体任务
    return {"messages": [result], "next": "planner"}
```

构建图结构
```python

# 构建图结构
from langgraph.graph import StateGraph, END

graph = StateGraph(AgentState)
graph.add_node("planner", planner_node)
graph.add_node("executor", executor_node)

## 设置入口点
graph.set_entry_point("planner")
## 添加条件边
graph.add_conditional_edges(
    "planner",
    lambda x: x["next"],
    {
        "executor": "executor",
        "end": END
    }
)
## 添加普通边
graph.add_edge("executor", "planner")

## 编译图
app = graph.compile()
```



## Demo:基于LangGraph的Research Agent

> https://github.com/google-gemini/gemini-fullstack-langgraph-quickstart

> 跟projects/MiniRAG的本质类似，只是这里使用了LangGraph+更加成熟的模型和tools进行构建
> 
> 而projects/MiniRAG是使用python直接构建了一个最小化的chatAgent

1. 接收用户问题
2. 自动生成搜索关键词
3. 执行网络搜索
4. 反思知识缺口
5. 多轮迭代深化研究
6. 最终生成带引用的高质量回答

```text
START
  ↓
generate_query           ← 初始生成多个搜索词
  ↓
web_research (并行)       ← 并行执行多个搜索任务
  ↓
reflection              ← 分析已有信息，判断是否充分
  ↙           ↘
否（继续研究）           是（足够）
  ↓                   ↓
web_research ←─┐    finalize_answer
               │         ↓
               └─────────┘
                           ↓
                          END
```


核心代码
```python
# 初始化状态
builder = StateGraph(OverallState, config_schema=Configuration)

# 构建多个基础的Node(基础操作)
builder.add_node("generate_query", generate_query)
builder.add_node("web_research", web_search)
builder.add_node("reflection", reflection)
builder.add_node("finalize_answer", finalize_answer)
# 构建交互流程
## 入口：生成多个查询词，比如生成：["quantum computing 2025 breakthroughs", "new quantum chips", "quantum supremacy update"]
builder.add_edge(START, "generate_query")
## 将每个搜索词作为独立任务发送到 web_research 节点，实现 并行执行多个搜索请求
builder.add_conditional_edges(
    "generate_query", continue_to_web_research, ["web_research"]
)
## 检索结果反思总结
builder.add_edge("web_research", "reflection")
## 如果检索结果不理想，继续web_research，如果理想则跳转到finalize_answer
builder.add_conditional_edges(
    "reflection", evaluate_research, ["web_research", "finalize_answer"]
)
## 总结答案->END
builder.add_edge("finalize_answer", END)

# 构建graph管理类
graph = builder.compile(name="pro-search-agent")
```























