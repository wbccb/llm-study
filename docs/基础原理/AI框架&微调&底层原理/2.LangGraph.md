# LangGraph

LangGraph是一个用于构建大模型语言模型Agent的编排框架，它是LangChain的一个扩展，旨在通过将步骤建模为图中的边和节点，构建强大并且有状态的多参与者应用程序

> `LangGraph`=`LangChain` +  图状态机 + 循环控制 + 多代理调度

> 使用`有向图`建模复杂的代理工作流，支持循环、条件分支、状态管理，是构建复杂、有状态、多步骤代理工作流的扩展工具，适用于`步步推理、需要循环或者反馈的流程`


比如下面的示例就展现出`LangGraph`基于图的声明式编程，每一个节点都是一个动作（比如调用LLM、执行tool工具），边表示状态转移
```python
from langgraph.graph import StateGraph, END

class AgentState(TypedDict):
    messages: Annotated[Sequence[BaseMessage], add_messages]
    next: str

graph = StateGraph(AgentState)
graph.add_node("planner", planner_node)
graph.add_node("executor", executor_node)
graph.add_conditional_edges("planner", router_func, {"continue": "executor", "end": END})
graph.add_edge("executor", "planner")  # 可以形成循环
app = graph.compile()
```

## 核心概念

图构建StateGraph，用于构建有向图

- `add_node()`：添加节点
- `add_adge()`：添加普通边
- `add_conditional_edges()`：添加条件边
- `set_entry_point()`：设置入口点
- `set_finish_point()`：设置结束点

### 状态
整个工作流中的共享的数据结构，通常使用`TypedDict`定义

### 节点
图中的执行单位，代表一个具体的操作，比如调用LLM、执行工具等

### 边

连接节点的路径，定义执行流程，主要有两种类型
- 普通边：固定从给一个节点到另一个节点
- 条件边：根据状态决定下一步走向


## 最小化demo

定义状态
```python
from typing import TypedDict, Annotated
from langgraph.graph.message import add_messages

class AgentState(TypedDict):
    messages: Annotated[list, add_messages] #自动合并消息
    next: str # 下一步执行的节点
```

创建基础的函数
```python
# 创建节点函数
def planner_node(state):
    # 处理规划逻辑
    return {"messages": [response], "next": "executor"}

def executor_node(state):
    # 执行具体任务
    return {"messages": [result], "next": "planner"}
```

构建图结构
```python

# 构建图结构
from langgraph.graph import StateGraph, END

graph = StateGraph(AgentState)
graph.add_node("planner", planner_node)
graph.add_node("executor", executor_node)

## 设置入口点
graph.set_entry_point("planner")
## 添加条件边
graph.add_conditional_edges(
    "planner",
    lambda x: x["next"],
    {
        "executor": "executor",
        "end": END
    }
)
## 添加普通边
graph.add_edge("executor", "planner")

## 编译图
app = graph.compile()
```