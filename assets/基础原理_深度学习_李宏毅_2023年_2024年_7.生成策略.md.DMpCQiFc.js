import{_ as a,c as t,a0 as o,o as r}from"./chunks/framework.OqxnQCTf.js";const h=JSON.parse('{"title":"生成式人工智慧","description":"","frontmatter":{"outline":[1,6]},"headers":[],"relativePath":"基础原理/深度学习/李宏毅/2023年&2024年/7.生成策略.md","filePath":"基础原理/深度学习/李宏毅/2023年&2024年/7.生成策略.md"}'),s={name:"基础原理/深度学习/李宏毅/2023年&2024年/7.生成策略.md"};function i(n,e,c,l,u,d){return r(),t("div",null,e[0]||(e[0]=[o('<h1 id="生成式人工智慧" tabindex="-1">生成式人工智慧 <a class="header-anchor" href="#生成式人工智慧" aria-label="Permalink to &quot;生成式人工智慧&quot;">​</a></h1><p>机器产生复杂（几乎无法穷举）有结构（由有限的基本单位构成）的物件</p><ul><li>文字：文字由 <code>token</code> 组成，每一个大模型训练前都会形成一定数量的 token，比如 <code>Llmam 2</code> 由 <code>32k</code> 个不同的 token</li><li>图片：图片由 <code>pixel像素</code> 组成，<code>8 BPP</code>-&gt; 256个颜色；<code>16 BPP</code>-&gt; 65536个颜色；<code>24 BPP</code>-&gt; 1670万个颜色</li><li>声音：声音由 <code>取样点Sample</code> 组成，有多少个数据取决于 <code>取样解析度</code></li></ul><p>主要分为两种策略：</p><ul><li>Autoregressive Generation</li><li>Non-Autoregressive Generation</li></ul><h2 id="autoregressive-generation" tabindex="-1">Autoregressive Generation <a class="header-anchor" href="#autoregressive-generation" aria-label="Permalink to &quot;Autoregressive Generation&quot;">​</a></h2><ul><li>优点：生成质量高，适合文字类的生成</li><li>缺点：需要按部就班，一个一个输出生成（包括图片像素和声音取样点），对于要生成大规模数据的物件，速度非常慢</li></ul><p><img src="https://github.com/user-attachments/assets/878d556f-07d8-47eb-a2cc-b3a43cefaffc" alt="Image"></p><h2 id="non-autoregressive-generation" tabindex="-1">Non-Autoregressive Generation <a class="header-anchor" href="#non-autoregressive-generation" aria-label="Permalink to &quot;Non-Autoregressive Generation&quot;">​</a></h2><ul><li>优点：生成速度快</li><li>缺点：生成质量低</li></ul><p><img src="https://github.com/user-attachments/assets/eafb704f-f613-4f3d-bdb1-a6cbcdae91be" alt="Image"></p><blockquote><p>但是使用 Autoregressive Generation 进行图片和声音生成实在太慢了，有什么办法改进 Non-Autoregressive Generation 速度吗？</p></blockquote><h2 id="图片和声音生成的策略" tabindex="-1">图片和声音生成的策略 <a class="header-anchor" href="#图片和声音生成的策略" aria-label="Permalink to &quot;图片和声音生成的策略&quot;">​</a></h2><h3 id="autoregressive-generation-non-autoregressive-generation-结合" tabindex="-1">Autoregressive Generation + Non-Autoregressive Generation 结合 <a class="header-anchor" href="#autoregressive-generation-non-autoregressive-generation-结合" aria-label="Permalink to &quot;Autoregressive Generation + Non-Autoregressive Generation 结合&quot;">​</a></h3><p><img src="https://github.com/user-attachments/assets/003fb4e8-edc3-4ffd-949e-ac22f1760b4a" alt="Image"></p><blockquote><p>那么 Autoregressive Generation + Non-Autoregressive Generation 是如何进行训练的呢？</p></blockquote><p><img src="https://github.com/user-attachments/assets/a0c039fa-a04a-427f-86e0-f40d10a2eb83" alt="Image"></p><h3 id="non-autoregressive-generation-多次生成" tabindex="-1">Non-Autoregressive Generation 多次生成 <a class="header-anchor" href="#non-autoregressive-generation-多次生成" aria-label="Permalink to &quot;Non-Autoregressive Generation 多次生成&quot;">​</a></h3><p>本质可以看作一次 Autoregressive Generation，但是需要的次数大大减少</p><p><img src="https://github.com/user-attachments/assets/6af39e98-64a0-4342-a373-0371ac8fd852" alt="Image"></p><hr><p><img src="https://github.com/user-attachments/assets/18cc557f-94a3-4da4-8a40-0bde27bb01f0" alt="Image"></p><hr><p>甚至我们使用 Non-Autoregressive Generation 多次生成可以模仿 <code>Autoregressive Generation + Non-Autoregressive Generation 结合</code>的模式，先生成一个压缩的版本（很小），然后最终再放大形成一个大的图片数据</p><p><img src="https://github.com/user-attachments/assets/0d357e7f-93d3-4edd-b43d-9c49fe44833d" alt="Image"></p>',25)]))}const m=a(s,[["render",i]]);export{h as __pageData,m as default};
